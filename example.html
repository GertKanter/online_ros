<!DOCTYPE html>
<html>

{{html_head}}

<body onload="init()">

{{html_header}}

<div style="float: left; width: 50%" class="main">
  <div id="main_header">
    <div id="example_title"></div>
    <div id="description"></div>
  </div>

  <div id="main_files">
    Files: <select name="files" id="file_list" size="1" onchange="file_list_select();"></select>
  </div>

  <div id="editor"></div>

  <div id="main_footer">
    <input type="button" value="Compile & Run" id="compile">
  </br>
  <span style="display: inline-block; padding-top: 4px;">Command: <b id="run_cmd"></b></span>
  </div>
</div>

<div id="feedback" class="feedback">
  <div class="tab-frame0" id="feedback0">
    <input type="radio" checked name="tab0" id="tab_terminal0"><label for="tab_terminal0">Terminal</label>
    <input type="radio" name="tab0" id="tab_topics0"><label for="tab_topics0">Topics</label>
    <input type="radio" name="tab0" id="tab_services0"><label for="tab_services0">Services</label>
    <input type="radio" name="tab0" id="tab_nodes0"><label for="tab_nodes0">Nodes</label>
    <input type="radio" name="tab0" id="tab_params0"><label for="tab_params0">Params</label>
    <input type="radio" name="tab0" id="tab_viz0"><label for="tab_viz0">Viewer</label>

    <div class="tab0">
      <textarea id="show_terminal0" readonly="readonly"></textarea>
    </div>
    <div class="tab0">
      <select name="topics" id="topic_list0" size="1" onchange="topic_list_select(this);"></select>
      </br>
      <textarea id="show_topic0" readonly="readonly"></textarea>
    </div>
    <div class="tab0">
      <select name="services" id="service_list0" size="1" onchange="service_list_select(this);"></select>
    </div>
    <div class="tab0">
       <select name="nodes" id="node_list0" size="1" onchange="nodes_list_select(this);"></select>
    </div>
    <div class="tab0">
       <select name="params" id="param_list0" size="1" onchange="param_list_select(this);"></select>
       <br>
       <textarea id="show_param0"></textarea>
       <br>
       <br>
       <input type="button" value="Set Param" id="set_param0">
    </div>
    <div class="tab0">
      <div id="roslib_viewer0"></div>
    </div>
  </div>



    <div class="tab-frame1" id="feedback1">
      <input type="radio" checked name="tab1" id="tab_terminal1"><label for="tab_terminal1">Terminal</label>
      <input type="radio" name="tab1" id="tab_topics1"><label for="tab_topics1">Topics</label>
      <input type="radio" name="tab1" id="tab_services1"><label for="tab_services1">Services</label>
      <input type="radio" name="tab1" id="tab_nodes1"><label for="tab_nodes1">Nodes</label>
      <input type="radio" name="tab1" id="tab_params1"><label for="tab_params1">Params</label>
      <input type="radio" name="tab1" id="tab_viz1"><label for="tab_viz1">Viewer</label>

      <div class="tab1">
        <textarea id="show_terminal1" readonly="readonly"></textarea>
      </div>
      <div class="tab1">
        <select name="topics" id="topic_list1" size="1" onchange="topic_list_select(this);"></select>
        </br>
        <textarea id="show_topic1" readonly="readonly"></textarea>
      </div>
      <div class="tab1">
        <select name="services" id="service_list1" size="1" onchange="service_list_select(this);"></select>
      </div>
      <div class="tab1">
         <select name="nodes" id="node_list1" size="1" onchange="nodes_list_select(this);"></select>
      </div>
      <div class="tab1">
         <select name="params" id="param_list1" size="1" onchange="param_list_select(this);"></select>
         <br>
         <textarea id="show_param1"></textarea>
         <br>
         <br>
         <input type="button" value="Set Param" id="set_param1">
      </div>
      <div class="tab1">
        <div id="roslib_viewer1"></div>
      </div>
    </div>


</div>


<script type='text/javascript'>

var example_info;

// ROS code
var ros = new ROSLIB.Ros();
var roslib_connected = false;
var interval_active = false;
var interval;

var interval_get_ros_details;

var viewer;
var markerClient;

function try_ros_connection() {
  if (roslib_connected == false)
  {
    ros.connect('ws://{{host_name}}:{{rosbridge_port}}');
  }
}

ros.on('connection', function() {
  roslib_connected = true;
  console.log('Connected to websocket server.');
  interval_active = false;
  clearInterval(interval);
  interval_get_ros_details = setInterval(get_ros_details, 500);

if (example_info.example.feedback_top[0].tab == "viz")
{
  if (typeof viewer != "undefined") {
    viewer.unsubscribe();
    delete viewer;
  }

  // TODO: The width and height need to come from somewhere meaningful
  viewer = new ROS3D.Viewer({
    divID : 'roslib_viewer',
    width : 300,
    height : 200,
    antialias : true
  });

  if (typeof markerClient != "undefined") {
    markerClient.unsubscribe();
    delete markerClient;
  }
  markerClient = new ROS3D.MarkerClient({
    ros : ros,
    tfClient : new ROSLIB.TFClient({
      ros : ros,
      angularThres : 0.01,
      transThres : 0.01,
      rate : 10.0,
      fixedFrame : example_info.example.feedback_top[0].frame[0]
    }),
    topic : example_info.example.feedback_top[0].topic[0],
    rootObject : viewer.scene
  });
}
  if (typeof example_info.example.feedback_top[0].tab == "topic" &&
    typeof example_info.example.feedback_top[0].topic[0] != "undefined") {
    set_topic(example_info.example.feedback_top[0].topic[0]);
  }

});

ros.on('error', function(error) {
  console.log('Error connecting to websocket server: ', error);
});

ros.on('close', function() {
  clearInterval(interval_get_ros_details);
  console.log('Connection to websocket server closed.');
});

var selected_topic_name;
var selected_param_name;
var topic_listener;

function set_topic(topic_name, id) {
  selected_topic_name = topic_name;
  var topic_type;
  if (topic_name == '/rosout' || topic_name == 'rosout_agg') {
    topic_type = 'rosgraph_msgs/Log';
  } else if (topic_name == example_info.example.feedback_top[0].topic[0]) {
    topic_type = example_info.example.feedback_top[0].msg_type[0];
  } else {
    // hope this works.
    topic_type = 'std_msgs/String';
  }

  if (typeof topic_listener != "undefined") {
    topic_listener.unsubscribe();
    delete topic_listener;
    document.getElementById("show_topic" + id).value = '';
  }

    // TODO: Why do I need to set the messagetype for the listener?
  topic_listener = new ROSLIB.Topic({
    ros : ros,
    name : topic_name,
    messageType : topic_type
  });

  topic_listener.subscribe(function(message) {
    // set 2 space tabs and get rid of the ""
    console.log("topic_listener.subscribe" + id)
    message = JSON.stringify(message, null, 2).replace(/\"([^(\")"]+)\":/g,"$1:");
    document.getElementById("show_topic" + id).value += message + '\r';
    document.getElementById("show_topic" + id).scrollTop = document.getElementById("show_topic" + id).scrollHeight;
  });
}

function topic_list_select(element) {
  set_topic(element.value, element.id.slice(-1));
}

var roslib_param;
function set_param(param) {
  selected_param_name = param;
  if (typeof roslib_param != "undefined") {
    delete roslib_param;
  }
  roslib_param = new ROSLIB.Param({
    ros: ros,
    name: selected_param_name
  });
}

function param_list_select() {
  var sel = document.getElementById("param_list");
  var sel_val = sel.options[sel.selectedIndex].value;
  set_param(sel_val);
  roslib_param.get(function(value) {
    document.getElementById("show_param").value = value;
  });
}

/**
 * Gets and updates the list of ROS topics, nodes, services, and parameters.
 * This is repeatidly called at an interval whilst the ROS bridge is connected.
 * TODO: It would be much better if this was pushed to us when a change happens.
 * At the least we could store the callback values and check if they have changed.
 */
function get_ros_details() {
  ros.getTopics(function(topics) {
    // TODO: It's a shame this doesn't also return the message types.
    for (var id = 0; id < 2; id++)
    {
      var sel = document.getElementById('topic_list' + id);
      sel.options.length = 0;
      for (var topic in topics)
      {
        // TODO: Also work out a way to remove the tf's that appear ... but only if they shouldn't!
        // This might need to become a user configurable parameter.
        if (topics[topic].indexOf('tf2_web_republisher') == -1)
        {
          var opt = document.createElement('option');
          opt.innerHTML = topics[topic];
          opt.value = topics[topic];
          sel.appendChild(opt);
        }
      }
      sel.value = selected_topic_name;
    }
  });
  ros.getNodes(function(nodes) {
    for (var id = 0; id < 2; id++)
    {
      var sel = document.getElementById('node_list' + id);
      sel.options.length = 0;
      for (var node in nodes)
      {
        var opt = document.createElement('option');
        opt.innerHTML = nodes[node];
        opt.value = nodes[node];
        sel.appendChild(opt);
      }
    }
  });
  ros.getServices(function(services) {
    for (var id = 0; id < 2; id++)
    {
      var sel = document.getElementById('service_list' + id);
      sel.options.length = 0;
      for (var service in services)
      {
        var opt = document.createElement('option');
        opt.innerHTML = services[service];
        opt.value = services[service];
        sel.appendChild(opt);
      }
   }
  });
  ros.getParams(function(params) {
    for (var id = 0; id < 2; id++)
    {
      var sel = document.getElementById('param_list' + id);
      sel.options.length = 0;
      for (var param in params)
      {
        if (params[param].indexOf('rosbridge_websocket') == -1 &&
            params[param].indexOf('rosapi') == -1)
        {
          var opt = document.createElement('option');
          opt.innerHTML = params[param];
          opt.value = params[param];
          sel.appendChild(opt);
        }
      }
      if (typeof selected_param_name != "undefined")
      {
        sel.value = selected_param_name;
      }
    }
  });
}

/**
 * This function updates the terminal feedback textbox.
 */
$(document).ready(function(){
  var socket = io();
  socket.on('compile_output',function(msg){
    for (var id = 0; id < 2; id++)
    {
      document.getElementById("show_terminal" + id).value += msg;
      document.getElementById("show_terminal" + id).scrollTop = document.getElementById("show_terminal" + id).scrollHeight
    }
  });
});



var files = {};
var editor = ace.edit("editor");
editor.setTheme("ace/theme/chrome");
var EditSession = ace.require("ace/edit_session").EditSession;
var editor_sessions = {};

var example_name = location.search.split('name=')[1];

$.get("/get_files?name=" + example_name, function (data) {

  // parse the data into the files for the editor and the general example information
   var parsed_data = JSON.parse(data);
   files = parsed_data[0];
   example_info = parsed_data[1];

   // load each file into its own editor
   var sel = document.getElementById('file_list');
   for (var filename in files)
   {
     var opt = document.createElement('option');
     opt.value = filename;
     opt.innerHTML = filename;
     sel.appendChild(opt);
     var filename_extension = filename.split('.').pop();
     editor_sessions[filename] = new EditSession(filename);
     if (filename_extension == 'cpp' || filename_extension == 'c')
          editor_sessions[filename].setMode("ace/mode/c_cpp");
     else if (filename_extension == 'xml')
          editor_sessions[filename].setMode("ace/mode/xml");
     else
          editor_sessions[filename].setMode("ace/mode/text");
     editor_sessions[filename].setValue(files[filename], -1);
   }

   // set the initial file for editing
   // TODO: Test if this is set / valid
   editor.setSession(editor_sessions[example_info.example.start_file]);
   sel.value = example_info.example.start_file;

   // set other parts of the page
   document.getElementById("run_cmd").innerHTML = example_info.example.run_cmd;
   document.getElementById("example_title").innerHTML = example_info.example.title;
   document.getElementById("description").innerHTML = example_info.example.description;
   document.getElementById("tab_" + example_info.example.feedback_top[0].tab).checked = true;

});


function file_list_select() {
  var sel = document.getElementById("file_list");
  var sel_val = sel.options[sel.selectedIndex].value;
  editor.setSession(editor_sessions[sel_val]);
  if (sel_val == 'CMakeLists.txt' || sel_val == 'package.xml')
  {
    editor.setReadOnly(true);
  } else {
    editor.setReadOnly(false);
  }
}

var runningCode = false;

$('#compile').on('click', function() {
  if (runningCode)
    return;
  runningCode = true;

  document.getElementById("compile").style.background='#FF8C00';
  roslib_connected = false;
  if (!interval_active)
  {
     interval_active = true;
     interval = setInterval(try_ros_connection, 2000);
  }

  for (var id = 0; id < 2; id++)
  {
    document.getElementById("show_terminal" + id).value = '';
    document.getElementById("show_topic" + id).value = '';
  }

  var code = {};
  for (var filename in editor_sessions)
  {
    code[filename] = editor_sessions[filename].getValue();
  }

  var json = {
    code_files: code,
    rosbridge_port: {{rosbridge_port}}
  };

  $.post("/compile?name=" + example_name, json, function(data, error, xhr) {
      document.getElementById("compile").style.background='#00FF00';
      runningCode = false;
  });
});


</script>

{{html_footer}}
  </body>

</html>
